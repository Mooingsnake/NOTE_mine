### 字符集
https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896

unicode：万国码，把所有国家语言的字符都编入其中，因为太多了所以要分区，称为Plane(平面),下面图片里面Scope代表分区的范围，而且是32bit的unicode

日常生活中的所有字符，包括中文，都在plane 0，可见用标准unicode是十分浪费的。

![v2-81d041143488f901271210e456b50945_r](https://user-images.githubusercontent.com/47411365/133041865-c8ded012-b11a-4c5b-a610-6778865f63a8.jpg)

字体：https://zhuanlan.zhihu.com/p/53036815  ，虽然没啥用，反正字体是另外一张表格，和unicode关系不大

### utf-8和utf-16

UTF-8并不是存储8bit的字符，utf-8是可变长的，在表示a的时候是8bit，在表示汉字“中”的时候是24bit，utf-8还支持ascii，二者可以无缝对接（也就是说前 127个编码和ascii一毛一样）

UTF-16只能储存16bit字符，这个字符集包含了汉字。

一个简单的想法就是，utf-8怎么才能告诉计算机这个字符是8bit，另外一个字符是16bit？还有字符是24，最高48bit？

__前缀不同__

```
用UTF-16表示"汉"

假如用UTF-16表示的话就是01101100   01001001(共16 bit,两个字节).程序解析的时候知道是UTF-16就把两个字节当成一个单元来解析.这个很简单.

用UTF-8表示"汉"

用UTF-8就有复杂点.因为此时程序是把一个字节一个字节的来读取,然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个单元来处理.

0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.@@ATTENTION@@ 就跟ASCII完全一样.

110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元

1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元.

以上内容转载自：https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html
```
类型强制转换的时候可能出现两个utf-8字符表示了一个utf16的情况，不然我也没办法解释为什么我输入了两个D，结果我的这行代码出了一个中文字,下面的图就是示例：
```
    case WM_CHAR:
        {
            static std::string title;
            title.push_back((char)wParam);
            SetWindowTextW(hWnd, (LPCWSTR)title.c_str());
        }
        break;
    }
```
![image](https://user-images.githubusercontent.com/47411365/133056535-2e1bd3ad-b3f3-4840-96b5-3bc886faffc5.png)


### 微软爸爸的w_char,LPWSTR
#### 首先是w_char

w_char，其实是wide character（宽字符）的缩写，wiki上说不同操作系统对宽字符有不同的实现方式，可能win是16bit，别的地方是32bit，或者映射不一样，如果这句话我理解有问题可以去看wiki的解释

这里主要研究微软爸爸的版本：https://docs.microsoft.com/en-us/cpp/cpp/char-wchar-t-char16-t-char32-t?view=msvc-160

我从中节选了一段：

The wchar_t type is an implementation-defined wide character type. In the Microsoft compiler, it represents a 16-bit wide character used to store Unicode encoded as UTF-16LE, the native character type on Windows operating systems. The wide character versions of the Universal C Runtime (UCRT) library functions use wchar_t and its pointer and array types as parameters and return values, as do the wide character versions of the native Windows API.

意思是说这是一种表示16bit的字符类型，而且是基于utf-16编码的，windows自己的操作系统完美支持这个字符集。

#### 然后是LPWSTR
微软爸爸的解释：https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/50e9ef83-d6fd-4e22-a34a-2c6b4e3c24f3

我继续节选：

The LPWSTR type is a 32-bit pointer to a string of 16-bit Unicode characters, which MAY be null-terminated. The LPWSTR type specifies a pointer to a sequence of Unicode characters, which MAY be terminated by a null character (usually referred to as "null-terminated Unicode").

大胆猜测LPWSTR：long pointer word string（并不知道w是什么意思，瞎猜的）

所以这是一个32bit的指针，指向了表示utf16的字符串，这个字符串的结尾应该是个null character终止符

#### LPWSTR和wchar_t

聪明的你一定知道了，LPWSTR其实可以指向wchar_t类型，我们看下面的例子,这是一个从char* 转化成LPWSTR的正确解法,mbstows（）是一个标准库的转化函数
```
char text[] = "something";
wchar_t wtext[20];
std::mbstowcs(wtext, text, strlen(text)+1);//Plus null
LPWSTR ptr = wtext;
https://stackoverflow.com/questions/6858524/convert-char-to-lpwstr
```
9.20 我发现一种更快乐的写法
```
std::wstring stemp = std::wstring(s.begin(), s.end());
LPCWSTR sw = stemp.c_str();
https://stackoverflow.com/questions/27220/how-to-convert-stdstring-to-lpcwstr-in-c-unicode   第二个答案
```
