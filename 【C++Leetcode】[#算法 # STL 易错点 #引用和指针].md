传送门：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/
##  STL易错点
1.vector虽然是个容器，但是如果函数的参数列表里不写上vector<int>&  还是没有传进对象，还是只有一个值，和java区分

 2.stack里面，只有top（）没有peek，pop也返回void
	
## 引用和指针 .为啥不能用push_back()啊
no matching member function for call to push_back
不是不能用这个函数，是函数里面应该是引用类型，但是你传了一个指针
### 啰嗦一下指针类型和引用类型
我们已经知道指针类型就是一个地址类型，它的值是一个地址，仅此而已
__引用类型__ 是一个语法糖，是为了让指针更容易理解和使用，虽然二者都指向了一个地址
### 太长不看版
最明显的是函数传参的时候为了把a传进去而不是单纯复制一个值
```
int func(int* t){
return (*t)++;  // 1.我们要把t解引用，这时候t是一个地址 2.为了不让++优先运算，要打括号 
}
int func(int& t){
return  t++;  // this is power
}
```
引用更安全，code也更干净，尽管引用能做的指针都能做
### 细节版
```
int a = 5;
int& ref = a;
//这时候 ref就是a，如果被编译那么就只有一个a。
```
举几个二者的不同处：
1.指针可以被重复赋值
```
int x = 5;
int y = 6;
int *p;
p = &x;
p = &y;
*p = 10;
```
引用不仅不能绑定别的对象，也不能被赋值给空值
```
int x = 5;
int y = 6;
int &q; // error
int &r = x;
r = y; // error 
```

## 算法. 二叉树遍历顺序  递归 迭代
遍历顺序分三种：
1.先序（先根）： 根 ，左子树， 右子树
2.中序（中根）：左子树， 根， 右子树
3.后序（后根）：。。。
### 递归 0(n) 0(n)
1.确定递归函数的功能（返回值，参数列表）
2.确定边界值（终止条件）
3.递推公式

__为什么这题需要新拟一个递归函数？__
1.需要在重复递归的过程中组装vector，这只要在函数里push_back（）就可以，而不是将返回值参与运算
2.你会发现处理边界值条件的时候 只能return 空值；而你并不需要return 任何东西，你只需要它停止
3.我们还需要一个参数位追踪这个vector，而原函数无法追踪
 
### 迭代
递归隐式地维护了一个栈，迭代显式地表达
__为什么这么说？__
递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

实操问题：0.一直向左之后遇到空
	1.之后每次退回都需要把栈里的右节点当成新树根节点
	2.但是遍历完新树后得回到栈记录的上上层的父级。
	3.此时只有一个[1]和经常出现的空值特别干扰
解决的时候：
  1.全程用root，可以指针指到的时候再处理nullptr。至于去左边还是右边，先去了再说

####  另外解释下为什么有 stack<TreeNode*> stk;
stk.push(root); 我们的root也是指针类型的
