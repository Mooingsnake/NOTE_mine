本文是油管频道的笔记 https://www.youtube.com/watch?v=Fx5bGZ3B_CI&list=PLqCJpWy5Fohd3S7ICFXwUomYW0Wv67pDD&index=4

- [窗体-window](#mainwindow)
- [3-信息-message](#message)
- [4-窗体信息-window-message](#window-message)
- [5-补充解释-WM_CHAR & MOUSE](#wm-char-mouse)

## window
微软的的窗体包括了窗体和消息。
<span id="mainwindow"></span>
### winmain
这是一个win32有关的项目，参考文档来自微软官方，如果想要知道相关函数，只需要搜索showWindow msdn就可以查找到

第一个坑是不要使用带console的tag的模板当作项目初始化，因为即使里面没有代码，即使里面设置subsystem是windows，运行程序的时候还是会找main函数。

而我们的入口函数是：WinMain

下面的代码主要做了三件事：1.// register window class，2. create window instance；3.show window function
```
#include <windows.h>
int CALLBACK WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,  // 重要的参数 long ptr command line ，是程序在运行时用户在命令行的一些参数，不过这里不收那种parsed array of tokens
    int       nShowCmd
)
{
    const wchar_t pClassName[] = L"hw3dbutts";
    // register window class , based on:
    // https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexa
    WNDCLASSEX wc = { 0 };    // WND= windows
    wc.cbSize = sizeof(wc);
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = DefWindowProc; // 重要！lpfnWndProc: long pointer function window procedure，即一个函数的指针，这个函数能控制这个窗口的所有message，当然这里是def（default）
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = nullptr;
    wc.hbrBackground = nullptr;
    wc.lpszMenuName = nullptr;
    wc.lpszClassName = (LPCWSTR)pClassName;
    wc.hIconSm = nullptr;
    RegisterClassEx(&wc);
    // create window instance
    // 参考网址 https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles
    // hwnd = handle the window
    HWND hWnd = CreateWindowEx(  // HWND 意思是：handle window，这里重点是CreateWindowEx这个函数
        0, (LPCWSTR)pClassName,
        (LPCWSTR)L"happy Hard Window",
        WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU,//一个参数多个含义：有title bar，有最小化，有菜单，类似单片机的参数设置套路
        200, 200, 640, 480,
        nullptr, nullptr, hInstance, nullptr
    );

    // show window function
    // 参考网址 https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
    ShowWindow(hWnd, SW_SHOW);
    while (true);
    return 0;
};
```
<span id="message"></span>
### Message
![image](https://user-images.githubusercontent.com/47411365/126618040-80c063a7-7f6a-411b-ab35-c18bef2c9e81.png)

简单解释下，上面的mouse_move 和mouse_click 是event,  这些事件将会存储在消息队列（message queue）里面，需要通过getMessage()获取

左边的Win32和App划分了功能区域，意思是上面是win32在自动操作，下面是程序员在app里可以控制的部分，我们可以看到win32
自动处理了事件，然后打包成一个消息队列，从一个GetMessage()开始后面还有Filter，Notify，translate等等操作（这里的话）TranslateMsg()被更多的使用

如果这里的message 是一个KEYDOWN message(红线位置),那么将会  变成WM_CHAR

重点函数是蓝色的GetMessage()和TranslateMsg() 以及 DispatchMessage(),DispatchMessage()会把消息重新传送给window

window实例里面会持有一个指针：WinProc,这个函数是一个回调函数，这个回调函数是不停的在被系统自己调用的，在上面代码中wc.lpfnWndProc = DefWindowProc; 就是这么回事，显然这里是进行设置了一个DEFAULT的窗口新建方式，
准备在Win32的流程里面调用该函数指针指向的函数

#### 关于GetMessage()这个函数
![image](https://user-images.githubusercontent.com/47411365/126830242-7a0f6887-2a8c-4327-8ecf-1f861d6d0d08.png)

当HWND是NULL的时候意味着接受1.当前线程中所有是NULL的窗体消息，2.当前线程的所有消息

顺便看一下Msg的结构，有助于理解

![image](https://user-images.githubusercontent.com/47411365/126830552-7b884518-94e2-414f-a93a-66dfb749b95e.png)

HWND是Msg发送的地方，UINT unsigned int，是message的编号，非常 __重要__，

WPARAM和LPARAM是两个32bit数据，根据不同的maeesga编号有不同的值

FilterMin 和 FilterMax都设置成0，则不过滤任何信息，全部接受

![image](https://user-images.githubusercontent.com/47411365/132942013-4454bf60-37ab-446c-a834-4fc24842d01c.png)

这个函数如果返回的是QUIT，那么返回的是0，如果出现error，返回-1，我们要保证这个函数一直返回（x > 0）的情况，不要用while(x)因为x可能是-1,while（-1）和while（1）等价，所以代码如下：

![image](https://user-images.githubusercontent.com/47411365/132942078-3b51418a-06ac-48c3-b9e7-dcec840922cd.png)



#### 运行看看
有意思的是关掉window并没有结束运行，这是因为DefWindowProc设置下并不能确认当前window关掉了application是否同样退出

#### 写一个自定义的window proc,在WinMain函数前面
```
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {// 这是一个自定义的wndproc，LRESULT是wndproc的一个标志，代表返回了32bit整数类型
    switch (msg)
    {
    case WM_CLOSE:
        PostQuitMessage(69);
        break;
    }
    return DefWindowProc( hWnd, msg, wParam, lParam) ;  // hwnd，一个用来生成msg的控制器，msg，是message 的id，
}
```
这个函数表示当关闭窗口的时候（msg == WM_CLOSE），我们会发送一个QUIT信号，使应用程序关闭

有意思的是我们在output界面只能收到The program '[11660] winmain.exe' has exited with code 0 (0x0).的消息，为什么不是69，而是0？

因为这个返回0其实是WinMain函数的return 0；如果想要看到返回的69，可以这么写：
```
    MSG msg;
    BOOL gResult;
    while ( (gResult = GetMessage(&msg, nullptr, 0, 0) )> 0) {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
        // 仍然毫无反应
    }

    if (gResult == -1) {
        return -1;
    }
    else {
        return msg.wParam; // 这里的msg就是WM_QUIT,这个量只有wParam有效。lParam无意义
    }
```
也就是说，我们自定义的WndProc函数中的PostQuitMessage(69);，恰恰就是 GetMessage(&msg, nullptr, 0, 0) )的部分，当>0的时候一直在while里循环，在退出以后，要么error，要么返回那个退出值

<span id="window-message"></span>
          
### 4-window-message
这个章节介绍不同的message，我们已经学习了关闭窗口WM_CLOSE（wm：windows-message）

参考网址： https://wiki.winehq.org/List_Of_Windows_Messages

如果用一个函数把所有窗体的message都显示出来，那么单单只是打开，就会有这些message：

![image](https://user-images.githubusercontent.com/47411365/126867291-c5fbc7c0-e7f3-40d3-8f23-bf46e02b00dd.png)

而如果把鼠标放在client region(指的是窗体框内的内容部分，对应窗体框包括title的是non-client region) 上面舞，出现的message就是下面这些，lp随鼠标位置不同也不一样，wp基本没有变化

![image](https://user-images.githubusercontent.com/47411365/126867374-4ca3580f-a639-42e3-84dd-c3b3150c5c54.png)

如果你抓着框舞，出现的message就是这些：

![image](https://user-images.githubusercontent.com/47411365/126867422-cb37b98e-369d-4cbc-a04d-438fe9c649f5.png)

如果你按下一些按钮，那么出现的message包括下面这些(KEYDOWN,CHAR,KEYUP)：

![image](https://user-images.githubusercontent.com/47411365/126867477-21a576de-a58f-4896-bc53-426800e057c8.png)

* 另外这里46的按下好多F，44是按下好多D

当然你可以看一下message的lparam 和wparam到底是什么，其实是单片机一样的32位携带各种信息开关的玩意儿，梦回一年前嵌入式有没有

![image](https://user-images.githubusercontent.com/47411365/126867666-79ef4ed0-6f3f-4297-8464-6c4770398a54.png)

<span id="wm-char-mouse"></span>
### 5-补充解释-WM_CHAR & MOUSE
WM_CHAR代表的是一些能写出字符的按钮，在ABDC中会出现，在F1F2中不会出现，另外，KEYDOWN不会表示字符大小写，但是WM_CHAR可以在shift+d的时候区分是大写字母

TranslateMessage(&msg)的作用之一就是在msg（）生成了WM_CHAR这个信息，要是不想要就不用调用

![image](https://user-images.githubusercontent.com/47411365/133035248-25c2dd58-cf0c-426b-b118-de3f643849e2.png)

```
#include <sstream>
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { // 这是一个自定义的wndproc，LRESULT是wndproc的一个标志，代表返回了32bit整数类型,然后是个callback函数
    switch (msg)
    {
    case WM_CLOSE:
        PostQuitMessage(69);
        break;
    case WM_KEYDOWN:
        if (wParam == 'F') {
            SetWindowText(hWnd, L"Respects");
        }
        break;

    case WM_KEYUP:
        if (wParam == 'G') {
            SetWindowTextW(hWnd, L"Danegerfield");
        }
        break;
    case WM_CHAR:  // 图1，按什么键打印在title
        {
            static std::string title;
            title.push_back((char)wParam);
            std::wstring stemp = std::wstring(title.begin(), title.end()); // 这里两句是为了把string 合法的转到LPCWSTR，
            LPCWSTR sw = stemp.c_str();
            SetWindowTextW(hWnd, sw);
        }
        break; 
    case WM_LBUTTONDOWN: // 鼠标左键，lParam低字节位表示x轴，高字节表示y轴  wParam记录是否按下ctrl，shift等，每个状态一个编码   图2，点击显示坐标
        {
             POINTS pt = MAKEPOINTS(lParam);
             std::ostringstream oss;
             oss << "(" << pt.x << "," << pt.y << ")";
             std::string str = oss.str();
             std::wstring stmp = std::wstring(str.begin(), str.end());
             SetWindowText(hWnd, stmp.c_str());
             break;
        }
       
    }   
    return DefWindowProc( hWnd, msg, wParam, lParam) ;
}
```

![image](https://user-images.githubusercontent.com/47411365/133978226-17c4c7ab-6ecc-47e3-8be9-c69719442fd9.png)
![image](https://user-images.githubusercontent.com/47411365/134006748-202e5f9a-b3fe-4b8e-b8f9-af89025c6ee5.png)


按照上文，每次按下按钮都会更新窗口标题

__TIPS__
```
             std::string str = oss.str();
             std::wstring stmp = std::wstring(str.begin(), str.end());
             SetWindowText(hWnd, stmp.c_str());
             不要写成
             std::wstring stmp = std::wstring(oss.str().begin(), oss.str().end()); 这里会判断两个迭代器的容器不是同一个，很有意思的一件事
```
<span id="dx11"></span>
## DX11

