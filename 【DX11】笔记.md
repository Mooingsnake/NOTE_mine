本文是油管频道的笔记 https://www.youtube.com/watch?v=Fx5bGZ3B_CI&list=PLqCJpWy5Fohd3S7ICFXwUomYW0Wv67pDD&index=4

- [窗体-window](#mainwindow)
- [信息-message](#message)



## window
微软的的窗体包括了窗体和消息。
<span id="mainwindow"></span>
### winmain
这是一个win32有关的项目，参考文档来自微软官方，如果想要知道相关函数，只需要搜索showWindow msdn就可以查找到

第一个坑是不要使用带console的tag的模板当作项目初始化，因为即使里面没有代码，即使里面设置subsystem是windows，运行程序的时候还是会找main函数。

而我们的入口函数是：WinMain
```
#include <windows.h>
int CALLBACK WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nShowCmd
)
{
    const wchar_t pClassName[] = L"hw3dbutts";
    // register window class , based on:
    // https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexa
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(wc);
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = DefWindowProc; // lpfnWndProc: long pointer function window procedure
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = nullptr;
    wc.hbrBackground = nullptr;
    wc.lpszMenuName = nullptr;
    wc.lpszClassName = (LPCWSTR)pClassName;
    wc.hIconSm = nullptr;
    RegisterClassEx(&wc);
    // create window instance
    // 参考网址 https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles
    // hwnd = handle the window
    HWND hWnd = CreateWindowEx(
        0, (LPCWSTR)pClassName,
        (LPCWSTR)L"happy Hard Window",
        WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU,//一个参数多个含义：有title bar，有最小化，有菜单，类似单片机的参数设置套路
        200, 200, 640, 480,
        nullptr, nullptr, hInstance, nullptr
    );

    // show window function
    // 参考网址 https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
    ShowWindow(hWnd, SW_SHOW);
    while (true);
    return 0;
};
```
<span id="message"></span>
### Message
![image](https://user-images.githubusercontent.com/47411365/126618040-80c063a7-7f6a-411b-ab35-c18bef2c9e81.png)

简单解释下，上面的mouse_move 和mouse_click 是event

左边的Win32和App划分了功能区域，意思是上面是win32在自动操作，下面是程序员在app里可以控制的部分，我们可以看到win32
自动处理了事件，然后打包成一个消息队列，从一个GetMessage()开始后面还有Filter，Notify，translate等等操作（这里的话）TranslateMsg()被更多的使用

如果这里的message 是一个KEYDOWN message(红线位置),那么将会  变成WM_CHAR

重点函数是蓝色的GetMessage()和TranslateMsg() 以及 DispatchMessage(),DispatchMessage()会把消息重新传送给window

window实例里面会持有一个指针：WinProc，在上面代码中wc.lpfnWndProc = DefWindowProc; 就是这么回事，显然这里是进行设置了一个DEFAULT的窗口新建方式，
准备在Win32的流程里面调用该函数指针指向的函数

#### 关于GetMessage()这个函数
![image](https://user-images.githubusercontent.com/47411365/126830242-7a0f6887-2a8c-4327-8ecf-1f861d6d0d08.png)

当HWND是NULL的时候意味着接受1.当前线程中所有是NULL的窗体消息，2.当前线程的所有消息

顺便看一下Msg的结构，有助于理解

![image](https://user-images.githubusercontent.com/47411365/126830552-7b884518-94e2-414f-a93a-66dfb749b95e.png)

HWND是Msg发送的地方，UINT unsigned int，是message的编号，非常 __重要__，

WPARAM和LPARAM是两个32bit数据，根据不同的maeesga编号有不同的值

#### 运行看看
有意思的是关掉window并没有结束运行，这是因为DefWindowProc设置下并不能确认当前window关掉了application是否同样退出

#### 写一个自定义的window proc,在WinMain函数前面
```
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg)
    {
    case WM_CLOSE:
        PostQuitMessage(69);
        break;
    }
    return DefWindowProc( hWnd, msg, wParam, lParam) ;
}
```
这个函数表示当关闭窗口的时候（WM_CLOSE），会发送一个QUIT信号，使应用程序关闭

有意思的是我们在output界面只能收到The program '[11660] winmain.exe' has exited with code 0 (0x0).的消息，为什么不是69，而是0？

因为这个返回0其实是WinMain函数的return 0；如果想要看到返回的69，可以这么写
```
    MSG msg;
    BOOL gResult;
    while ( (gResult = GetMessage(&msg, nullptr, 0, 0) )> 0) {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
        // 仍然毫无反应
    }

    if (gResult == -1) {
        return -1;
    }
    else {
        return msg.wParam; // 这里的msg就是WM_QUIT,这个量它
    }
```
<span id="dx11"></span>
## DX11

