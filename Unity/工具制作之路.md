# 要义
1. 比起通过优先级匹配，清楚的命名指向通常更好（完全可控就是爽！）
2. 比起设计初始就灵活可拖拽，考虑一下直接限定死，牺牲了拖拽，但一键生成就是爽！

# 对比
比较一些工具之间的难用和易用点
## YIUI vs CodeBind
https://github.com/LiShengYang-yiyi/YIUI

https://github.com/XuToWei/CodeBind

1. 相对来说YIUI会庞大全面很多，但codeBind只要点击一次，不用拖拽真的太舒服了（能忍，但老拖拽太烦了）
2. 后面实际体验来说，YIUI非常笨重，修改很困难，很多功能也基本不用，吃透大框架本身就是一些难点

   i. 比如YIUI是伪堆栈，ACBC的打开顺序会变成CBA，但需求可能需要的是CBCA（YIUI的界面都是单例导致的）此时回退到第二个C界面当然展示的是C界面的内容。但如果想保留第一个C界面的数据就需要另外制作一大套数据存储堆栈来保持界面了
   
   ii. 比如YIUI只提供了异步加载的方法，一些同步逻辑需要等到页面加载完全之后再处理，比如场景跳转的时候，先卸载后加载的逻辑不是同步的，时序上会出现UI全部卸载，中间空出天空盒，过一会再出现界面的情况，需要await到底才行（能修，但老是出现真的很烦）

   iii. 比如YIUI循环嵌套做的不是很好，每次改动到这些界面的嵌套节点的时候，高概率主界面会出现一些引用缺失，再启动游戏需要reimport才能行
   
   


# 实现技巧
## inspector上展示
1.  ```[SerializeField, LabelText("标题的父节点")] protected RectTransform RtfTitleRoot;```
 <img width="658" height="36" alt="image" src="https://github.com/user-attachments/assets/bb886a30-0310-484d-b37a-2d54bab985ce" />
 
2. ```  [Title("左上角按钮")] ```
<img width="634" height="70" alt="image" src="https://github.com/user-attachments/assets/37f66b52-0d47-4c16-94e0-8c3fd31413c0" />
 
