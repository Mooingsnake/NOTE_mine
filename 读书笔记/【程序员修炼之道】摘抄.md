#### 我为什么要做摘抄
 - 1.分享给他人。  如果要让别人快速了解一本书的好，最快的就是看摘抄
 - 2.加深印象，快速回顾。  手打一遍记性更好，在网上有记录那不用带厚厚的书也能回顾内容
 - 3.对自己的思考做记录。  就像日记一样，思绪一闪而过常常忘记，哪怕是做年终总结，有记录就比没记录要好，我不能记得一年内大大小小所有知识点，天天熬夜忘的也快。

## 2022/1

#### tip1：人生是你的  p2
程序员无所不能系列。

> 人生是你自己的，是你在拥有，经营，和创造。

> 软件开发在任何职业列表中，绝对是你自己最能掌控的职业之一。我们的技能供不应求，我们的知识不限于低于，我们可以远程工作，我们收入颇丰。我们真的能做我们想做的任何事情

#### tip6 知识组合 p14
多样性的知识总是需要的，要像吃饭一样荤素搭配比例规范，然后记得按时吃饭，有意识的吃荤菜和蔬菜，一直到一顿不吃绿叶子浑身难受。

如果我学的是unity，那我就应该了解unity组件的原理，图形学，c#原理，unity涉及的方方面面都是不错的突破口。不要止步于此，ue4也可以去看看其中的特性。
> 1.正规投资者有定期投资的习惯

> 2. 多样化是长线成功的关键

> 3.平衡保守型和高风险高回报型投资的组合

> 4.用低买高卖获得最大的汇报

> 5.定期审查和重新平衡投资组合 

> 诀窍是让自己一开始就这么做，并养成习惯。制定一个你能遵循的例行规程，照此去做，直到大脑将其内化。

> 低买高卖的意思是在一项新兴技术变得流行之前就开始学习。

> 对于多样化，汽贸要知道目前工作中特定技术的来龙去脉，但不要就此打住。

#### tip9 对知识组合做定期投资 p16

> 【读技术书】虽然网上有大量的短文和偶尔可靠的答案，但深入理解还是需要去读长篇的书。浏览书店页面后挑选你当前项目主题相关的技术图书。__一旦你养成习惯，就每月读一本。在你掌握了当前正在使用的所有技术后，扩展你爹的领域，学习一些和你的项目不相关的东西。

>【上课】在本地大学或是网上找一些有趣的课程，或许也能在下一场商业会展或是技术会议上找到。

> 【加入本地的用户组和交流群】独来独往对你的职业生涯是致命的；了解一下公司外的人们都在做什么。

> 【尝试不同的环境】如果你只是在windows下工作，那就花点时间在linux上，如果你只是用简单的编辑器和makefile，那就试试最新的酷炫复杂的IDE，反之亦然。

> 【与时俱进】关心一下和你当前项目不同的技术，阅读相关的新闻和技术贴。

#### tip 6 知识组合 p19
> 走出去和那些与你当前项目无关的人谈谈技术，和别的公司的人聊聊。试着在公司餐厅建立你的人脉，或是去参加本地的聚会，找一些志同道合的人。

#### tip7 交流 p21
> 计划好你想说什么，写一个大纲，然后问自己：“这是否用正确的方式向我的听众传达了我像表达的东西？” __精炼到不能更精炼为止__

> 当你要参加一个重要的会议或给一个大客户打电话时，记下你想要沟通的想法， __并准备多个让对方理解的策略。__

> 只要有可能，让读者参与倒文档的初稿中来。听取他们的反馈，汲取他们的智慧。

**我需要着重地高亮以下内容：**

```我就经常滥用注释，实际上如果能一眼看清楚的代码，是不需要注释的，在非api下的代码都应该限制的使用注释（或者不用），并且注释内容更应该是为何存在。```

> 用源码中的注释生成好看的文档非常容易，建议给模块和导出函数都加上注释。

> 给每个函数都分别叫上注释，我们并不赞同这种做法。这种注释方式实际上会导致代码更难维护：一旦你想改点什么，就需要改变两个东西。因此，将非API的注释限制在只用来讨论其为何存在机器意图、目标。当代码已经展示了事情怎样完成时，注释是多余的——因为这违反了DRY的原则。

> 注释源码是一个绝佳的机会，可以用来记录那些在其他地方无法记录的项目细节：工程上的权衡，为什么要做决定，放弃了哪些替代方案等。

```所以我们常常能在大点的官方项目里看到成段的注释信息```

### 第二章 务实的方法
#### tip14 优秀的设计比糟糕的设计更容易变更 p28
> 为什么解耦很好？因为通过隔离关注焦点，可让每一部分都容易变更。——此谓ETC！
> 
> 为什么单一职责原则很有用？ 因为一个需求变化仅体现为某一单一模块上的一个对应变化。——此谓ETC！
> 
> 为什么命名很重要？因为好的命名可以使代码更容易阅读，而你需要通过阅读来变更代码。——此谓ETC！

#### tip15 DRY不要重复自己 p31
> 在一个系统中，每一处知识都必须单一、明确、权威地表达

例如命名规范文档，不要可能，不要归类，要权威地说“你必须”

> (p32) 当代码的某个单一方面必须改变时，你是否发现自己在多个地方以多种不同的格式进行了变更？有没有同时修改代码和文档，或是同时变更数据库上车吗和代码中相关的数据结构？如果这类情况发生，你的 代码
> 并不满足DRY

> 无论什么时候，只要模块暴露出数据结构，就意味着，所有使用这个数据结构的代码和模块的实现产生了耦合。

##### 表征的重复
> 代码要和外部世界打交道，包括通过API访问的其他库，通过远程调用访问的其他服务，一起来自于外部的数据，等等。几乎每次做这些事情的时候，都会以某种的方式违背DRY：代码必须持有外部那个东西已经蕴含的知识。它需要了解API，数据的schema（schema，数据库的结构），出错码的含义，或是其他什么东西。……一端发生改变，另一段就会坏掉。
> 
> 这类重复无法避免，但有办法减缓。
我发现这个API工具可能指的是swagger这样子的东西，但是好像和后端关系很大，我不是很懂。
> 1.对于内部API，找个工具，可以生成文档，模拟API，功能测试，理想情况下，可以API保存在一个中心仓库种，以便不同团队共享。
> 
> 2.openAPI
> 
> 3.你可以不必通过手工编写代码将要储存的数据包含其中，可以直接从schema生成容器代码（比如luban）
> 
> 一张表驱动的校验组件，让其可以校验保存有数据的表，保证其包含了你需要的数据，以及这些数据符合你需要的格式，再强调一下，你同样可以用API生成工具来完成这项校验。
>

#### 正交性（p40）
> 在计算机科学中，这个术语象征着独立性和解耦性。对于两个或多个事物，其中一个改变不影响其他任何一个，则这些事物是正交的。
> 在良好设计的系统重踏，数据库相关的代码应该和用户界面保持正交：你可以变更界面但不影响数据库，切换数据库而不必更换界面。
##### 正交的好处
 1. 获得生产力。
> 编写相对较小的，独立自主的组件必编写完整一大块代码要容易。
> 
实际上，什么是职责定义清晰很有必要讨论，比方地图的功能，什么样的功能是地图自己的，如果人物的技能要和地图交互，这些应该地图管吗，如果地图要换个数据库存储，那地图的功能里就不应该有解析txt的函数。
> 正交的方法同时促进了重用。如果组件有一个职责定义清晰的规范，就能以原作者预想不到的方式于新组件组合使用。
> 
我的建议是多看开源代码，这是一个挺有意思的课题，关于如何定义每个代码的职责。

> 假设一个组件能做M件独特的事情，另一个能做N件。如果它们是正交的，组合起来就能做M\*N件事
 
 2. 减少风险
> 代码种病变的部分被隔离开。
> 
> 这样获得的系统不那么脆弱。对特定区域进行小的变更和修复后，因此产生的任何问题都将局限于该区域。
> 
> 正交系统可能更利于测试。

##### 设计（p42）
> 系统应该有一组相互写作的模块构成，每个模块实现的功能应该独立于其他模块。又是这些模块组件被组织到不同的层次上，每一层都做了一级抽象。这种分层的实现是设计正交系统的有力途径。因为每一层指使用它下面一层提供的抽象，所以可以在不影响代码的情况下及其灵活地更改底层实现。
比方说我们不能直接用身份证id当作用户id使用，尽管它的确唯一：
> 还有问问自己，你的设计于现实世界的变化有多大成都的解耦。邮政编码，社会保险号或者身份证号，电子右键地址以及域名，都是外部标识符，你无法完全控制，它们都可能因为某些原因而该百年。不要依赖那些你无法控制的东西。

##### 工具包和程序库（p44）
> 在引入第三方工具包和程序库时，请注意保持系统的正交性。技术选择要明智。
> 
> 当你拿出一个工具包，问问自己，它是否会将一些不应该有的变化强加给你的代码。

##### 编码
> 编写害羞的代码——不要给其他模块透露任何不必要的信息。
> 
> 避免全局数据。即使只打算对全局数据进行读操作，也可能引发问题（例如突然需要将代码改为多线程的情形）一般来说，如果总是显式地将任何需要的上下文传递给模块，那么代码会更容易理解和维护
> 。
> 避免相似的函数。重复代码是结构问题的症状。想要更好的实现，可以看看《设计模式》种的策略模式

##### 测试
> 你可以启用月度报告，去分析每个BUG修复锁影响的源文件数量的趋势。


#### 可逆性（p49）
就像咱一去不返的高中一样，选择一条职业会减少其他职业的可能。
> 一旦决定使用某个供应商的数据库，或是某个架构模式，抑或是特定的部署模型，就是在采取一系列无法回退的行动，除非付出巨大的代价
> 
> 假设项目开始时一个基于浏览器的应用程序，但后来，市场营销人员认识到他们真正想要的是一个移动APP。这回给你造成多大的困难呢？理想情况下，这不应对你早场太大影响，至少在服务器端时这样。
#### 不设最终决定（p50）
将第三方API隐藏在自己的抽象层之后。将代码分解为多个组件：即使最终会把它们部署到单个大型服务器上，这种方法也必一开始做庞然大物，然后再切分要容易得多。

#### 曳光弹（p52）
> 预备，开火，瞄准
来看源码阅读方式：
> 着手一个有五个架构层的系统。我们对它们怎么集成起来的有些疑惑，所以就先去找一个简单的特性，用来实验一下这些层析时如何一起工作的。
> 
> 曳光代码不是一次性的：编写它是为了持续使用。代码种需要半酣所有的错误检查结构，文档，自检查这些任何生产代码都应该巨白的东西。它只是功能还不完整。但是只要再哥哥组件间，从一头到另一头全部大同，就可以检查出离目标有多么接近，并在必要时做出调整。

#### 原型（p57）
##### 需要做原型的东西
> 你会用原型来研究什么类型的东西呢？答案是，任何有风险的东西，任何之前没有尝试过或对最终系统来说很关键的东西，任何未经证实。实验性或可以的东西，比如：架构，已存在的系统中的新功能，数据结构或外部数据的内容，第三方工具或组件，性能问题，用户界面设计

##### 怎么样使用原型
> 可以忽略的细节：正确性（用替代数据），完整性，健壮性，格式（不需要太多注释和文档）
> 由于原型需要跳过细节，专注于它所考虑的系统的特定方面，所以你可以能想用高阶脚本语言来实现原型——比项目其他部分高阶一些（python或ruby），如论如何都是要丢掉原型的。
> 脚本语言可以很好的充当“粘合剂”，将低阶代码块组合成新的搭配。使用这种方法可以快速地将现有组件组装为新的配置，一边了解其工作原理。

##### 制作架构原型
> 你可能希望再架构原型中找打其相关问题的答案：
> 
>  主要组件的职责是否恰当，有没有定义清晰？
>  
>  主要组件之间的协作是否定义清晰？
>  
>  耦合度最小化了吗？
>  
>  你能确定重复的潜在来源吗？
>  
>  接口的定义和约束能否接受？
>  
>  在执行过程中是否每个模块都有访问所需数据的途径？在需要数据的时候，能访问到吗？

#### 领域语言（p60）
> 语言之界限，即是一个人世界之界限。
> 
> 静态类型还是动态类型，早期绑定还是晚期绑定，函数式还是面向对象，继承模型，mixin，宏机制——所有这些对问题的解决方案，可能是提供建议有可能扰乱视听。同样是设计解决方案，用C++的方式和用Haskell结果会大不相同。
说实话我整一个没看懂，但是好想懂（主要是举了RSpec和Phoenix这两个例子讲路由）

#### 估算（p68）
> 理解在问什么
> 
> 对系统建模。对于一个项目，模型可能是开发组织在开发期间需要的每个步骤，以及关于系统可能如何实现的粗略图景。
> 
> 把模型分解成组件。一旦得到了模型，就可以将其分解为组件。你需要发掘出描述这些组件如何交互的数学规则。
> 
> 确定每个参数的值。关键是找出那些参数对结果影响最大，集中精力确保其近乎正确。一般来说，就重要性而言，把价值累加到结果的参数，明显低于对结果有乘法或除法效应的参数。
> 
> 计算答案。注意结果的精度表示，四分之三秒出啊打出与750ms不同感觉的精度
> 
> 记录你的估算能力。
> 
> 估算项目进度，每个PERT人物都有一个乐观的，一个最有可能的和一个悲观的估算。
> 
例如我以为摘抄80页内容可以在一小时完成，实际上我从八点写到零点（包括摸鱼时间），才写了40-68页。

### 基础工具（p74）
> 如果感觉手头的工具搞不定遇到的问题，先记录下来，再去试试其他的工具，只要它足够强大，就可能对你有帮助——让需求趋势你不断选购新的工具。
> 
> 我们相信，纯文本是将只是持久地储存下来的最佳格式，纯文本赋予我们操作知识的额能力，既可以用手工的方式，也可以用编程的放hi进行操作。
> 
> 什么是纯文本。 牛奶生菜咖啡是纯文本，dfasihoi324不是。我们希望纯文本可以被人类直接阅读。

#### 文本的威力
> 所谓纯文本，不是说文本是无结构的：HTML，JSON，YAML这些都是纯文本。网络上各种基本协议也大多如此，比如HTTP，SMTP，IMAP，
> 
> 为防备老化而加的保险。  如果存储格式过时，人类可读的版本至少比不可读的好点。
> 
> 杠杆效应。  从版本控制系统到编辑器，再到命令行工具，计算领域中的所有工具都可以对纯文本进行操作。
> 
> 易于测试。

#### shell游戏（P79）
> 对操作文本文件的程序员来说，工作台就是指令shell。你可以在shell里启动应用程序。调试其。浏览器。编辑器和工具，可以搜索文件，查询系统状态，并将结果过滤后输出。此外，可以通过对shell编程构建出复杂的宏指令，来处理经常要干的事情。
> 
> 图形界面非常棒。你将无法把常见的任务自动化，或是无法充分利用工具所能提供的强大功能。并且你也无法通过组合你的工具来创建定制的宏工具。
> 
> GUI环境通常局限于其设计者所期望的功能。非要超越设计人员提供的模型，往往会遭遇挫折。
> 
以下的IDE就是典型的GUI，而vim则是命令行工具。
> 假设需要在IDE集成一个代码预处理程序，除非IDE设计者明确为这个功能提供了狗子，否则就是做不到。

#### 发挥shell的威力（p80）
> 熟悉shell之后，你会发现生产率大幅提高。需要一份所有java

