

### p40 C 语言的起源

- **C was closely tied with the Unix operating system.** C was developed from the beginning as the
system programming language for Unix. Most of the Unix kernel (the core part of the operating
system), and all of its supporting tools and libraries, were written in C. As Unix became popular in
universities in the late 1970s and early 1980s, many people were exposed to C and found that they
liked it. Since Unix was written almost entirely in C, it could be easily ported to new machines,
which created an even wider audience for both C and Unix.

  c和unix操作系统紧密联系。 大多数的unix内核，以及他们的支持工具，库，都是用c写成的。
- **C is a small, simple language.** The design was controlled by a single person, rather than a committee,
and the result was a clean, consistent design with little baggage. The K&R book describes the
complete language and standard library, with numerous examples and exercises, in only 261 pages.
The simplicity of C made it relatively easy to learn and to port to different computers.

  c是一个很小，很简单的语言。设计者不是一个委员会而是一个人，所以它简单好用，K&R书就能描述完整个语言和标准库，甚至包含了大量的例子和联系，仅仅只有261页。

-  **C was designed for a practical purpose.** C was designed to implement the Unix operating system.
Later, other people found that they could write the programs they wanted, without the language
getting in the way

  c就是为了实现unix操作系统而诞生的，所以别的程序员想写程序的时候不会被语言问题绊倒
  
  ## 1.2 Programs Are Translated by Other Programs into Different Forms
  ![image](https://user-images.githubusercontent.com/47411365/148670033-1603d060-b2d9-4f1e-9593-c0ba401c27ed.png)

可以看到前三个 hello.c/hello.s/hello.i 都是text文本文件，后面两个是二进制文件，过程经历了源文件-》简单修改-》改成汇编-》转成二进制并链接-》变成可执行。
- Preprocessing phase
  会处理这个“#include <stdio.h>”并形成一个.i为文件名后缀的文件
- Compilation phase
  从hello.i变成hello.s ，翻译成汇编语言
  
  ![image](https://user-images.githubusercontent.com/47411365/148690529-dc33d487-f1ce-4c3e-9eaf-3d335822f160.png)

- Assembly phase
   下一步，从hello.s变成机器语言，同时打包成一个relocateable object的程序，并且储存结果在hello.o里面
  （Next, the assembler (as) translates hello.s into machinelanguage instructions, packages them in a form known as a relocatable object
program, and stores the result in the object file hello.o.）
- Linking phase.
  我们调用了printf，这是个c的标准库函数，存在在一个独立的预编译对象文件“printf.o”里，这个文件会合并到我们的hello.o程序里。linker主管合并，结果是hello文件便成了可执行文件，并且可以被加载进内存里，被操作系统执行。
  （. The printf function resides in a separate precompiled object file called printf.o, which
must somehow be merged with our hello.o program. The linker (ld) handles
this merging. The result is the hello file, which is an executable object file (or
simply executable) that is ready to be loaded into memory and executed by
the system.）

> GNU事什么
> 一个免税的组织，GNU project开发了一个除kernel以外的环境的主要组件，主要包括：emacs editor, gcc compiler, gdb debugger,
assembler, linker, utilities for manipulating binaries, and other components。GCC编译器已经逐渐支持多个语言，比如e C, C++, Fortran, Java, Pascal, Objective-C, and Ada。另外GNU的理念事免费！

## 1.3 It Pays to Understand How Compilation Systems Work 
理解编译系统如何工作是有益的。

- **优化程序性能。** 其实现代的编译器已经很完善可以生成很不错的程序了，但是我们的c语言还不行，我们仍然需要了解机器代码和不同的c语言段是如何翻译成各种汇编语言的。比如，switch真的永远比ifelse好用嘛？指针引用比数组下标更高效吗？一次函数调用会产生多少开支？while循环比for循环更高效吗？为什么在我们循环增加一个数的时候，局部变量比引用快那么多？通过简单修改几个括号，函数怎样运行的更快？
  
  我们会在第三章介绍x86-64，这是最近几代linux，windows，mac的机器语言。我们表述不同的c语言结构如何被编译器翻译成不同的程序。在第五章，你会学到如何调教你的c程序，让c更快更强。在第六章你可以从层级内存的角度让你的c语言剥削你的内存。
- **理解链接时出现的错误**。 连接器报错cannot resolve reference怎么办？用c语言定义两个全局变量但是在不同的文件里会怎样？静态库和动态库有什么区别？为什么我们在命令行列出library的时候顺序是重要的？最恐怖的是，为什么有些链接错误在运行时报错？你会了解这些答案在第七章
- **避开安全漏洞**。 缓存溢出是最入门的安全漏洞（学校里搞网安的来讲课就是在说溢出漏洞）。最开始的一步就是数据和控制信息存在程序栈的后果（栈溢出嘛），第三章会讲

## 1.4 Processors Read and Interpret Instructions Stored in Memory
处理器可以读取和解释存储在内存中的指令

假设这个时候hello已经变成一个可执行文件存在在硬盘上了。我们用linux运行这玩意就应该是这样：
![image](https://user-images.githubusercontent.com/47411365/148777511-52c6d428-9f9d-444d-96fc-b82893977de8.png)

shell是命令行的一个翻译器，给你一个提示，等你输入，然后运行你的输入。如果你写的东西不是内置的shell语句，那么就会去找对应有没有这个可执行文件。hello文件运行后打印“hello world”然后终止，shell打印一个提示语以后继续等待用户输入。
![image](https://user-images.githubusercontent.com/47411365/148778017-5858ecd2-152e-4489-8b82-91bbc635efd4.png)

### 1.4.1 Hardware Organization of a System
系统的硬件组成

#### Buses （总线）
bus就是电线，传输电信号，一般而言一排线组成一个字（ Buses are typically designed to transfer fixed-size chunks of bytes known as **words**。）然后字就变成了基本单位了，一般系统不是32位就是64位，所以一个字不是32位就是64位
#### I/O Devices （io设备）
键鼠输入，显示屏输出，还有一个硬盘长期存储程序和数据，hello就存在硬盘里。每个io设备都通过一个适配器或者控制器连在总线上（Each I/O device is connected to the I/O bus by either a controller or an adapter.）两者的区别主要在包装上面。控制器一般是设备本身，或者主板上的芯片组。适配器是主板上可插拔的卡。

第六章会讲io设备如何工作，第十章可以编写io程序。
#### Main Memory（主存）
主存用于控制器执行程序时候的暂时存储。物理上，主存往往由DRAM（dynamic random access memory）芯片组构成。逻辑上是线性的字节数组（a linear array of bytes），每一个有自己独立的地址（从0开始）。程序最后也可以归为字节组成的。数据项大小随类型有变化，short 2 bytes， float 4 bytes， long和double 8 bytes。
#### Processor（处理器）
central processing unit (CPU)也叫做处理器。就它在流水线地处理各种指令，核心是一个word-size的寄存器（PC program counter）。计组的老朋友了。

从主机的电源开始亮起到电源断电，处理器就像心脏一样任劳任怨的处理数据。处理器处理的指令都是很简单的那种，比如我大学计组学的MIPS。简单介绍几个：Load，Store，Operate，Jump


### 1.4.2 Running the hello Program
首先，是shell在运行它自己的程序：等待我们输入命令，我们在键盘打入./hello以后，shell会把它存在内存中，看图，在最右边：
![image](https://user-images.githubusercontent.com/47411365/148787425-dec4c5a9-bb0a-474a-b2a7-1ef2c747cb5f.png)

然后我们按回车，shell知道我们命令结束。shell会加载可执行的hello文件，通过执行一系列的复制指令操作，把hello文件的数据和信息从硬盘复制到内存。（The shell then loads the executable hello file by
executing a sequence of instructions that copies the code and data in the hello object file from disk to main memory）

我们使用一种DMA技术（direct memory access (DMA, discussed in Chapter 6)）这样数据可以从硬盘直接流入内存，不经过CPU。

内存加载完毕以后CPU就可以执行hello里面的指令了

## 1.5 Caches Matter
一件很重要的事情是，系统总是浪费时间在把信息从A点移动到B点。本来在硬盘上的机器指令在加载的时候也要复制到内存里去，处理器执行这些数据又要把指令从内存转移到处理器中。从程序员的角度，这种移动是开销，减慢了程序的“真正的工作”。如何让拷贝尽可能的快成了一个课题。

硬盘可能比主存大了1000倍，但是可能比主存速度慢了10000000倍。

相似的，寄存器存的少，主存存的多，但是处理器比主存快了100倍。甚至发展到现在，处理器-内存之间的差距仍在增加。让CPU跑的快比让内存条跑的快容易和便宜多了。

让我们引入Cache：L1 Cache上有数万个字节，几乎能像寄存器那样快； L2 有十万到百万个字节，处理器（processor）访问L2的速度是L1的五倍。

L1L2共同实现了一个硬件技术：SRAM(static random access memory )。现在很多系统有L1，2，3，第六章会接着讲。

![image](https://user-images.githubusercontent.com/47411365/148961767-88ea30e4-34b2-4694-b8dd-8e2112f9d2ed.png)

## 1.6 Storage Devices Form a Hierarchy
存储设备构成层次。

更大更慢的设备之前插一个小又快的设备是一个普遍概念。每一个计算机系统存储结构都是层级下降的。上图展示的最下面的服务器也有可能是狗比腾讯那样，把用户手机当成了自己的分布式存储点。

## 1.7 The Operating System Manages the Hardware

操作系统有两个目的：1.保护硬件不轻易被用户程序读取，2.把多种多样的硬件接口抽象出来形成统一的形制开放给用户程序。，下面是对io设备，主存，处理器的抽象：

### 1.7.1 进程
A process is the operating system’s abstraction for a running program。
进程是一个运行程序对操作系统的抽象。

> unix 的起源
> 1960年全是超大型系统，在1970年贝尔实验室的几个人从Multics里借用了：层级文件系统，shell作为用户层级的进程的新的思想。用机器码写了一个系统，1973年用c重写了一遍。在1980年左右，Berkeley的研究者引入了虚拟内存的概念，形成了BSD（(Berkeley Software Distribution），同时贝尔实验室发布了自己的版本：s System V Unix，之后的 Sun Microsystems Solaris system就是继承了这两个系统的特征。
>
> IEEE在这之后统一规范，主要的内容有： that cover such issues as the C
language interface for Unix system calls, shell programs and utilities, threads, and network programming.

CPU多开多个进程反复横跳的技术叫做“context switch”，context，表示进程所需的状态信息，比如pc值，寄存器文件，主存内容。我们来看shell打开hell的进程switch：

![image](https://user-images.githubusercontent.com/47411365/149184151-1dd46751-1907-460b-8f89-8940b2a03cba.png)

运行hello，shell调用system call，系统保存shell的context，新建hell进程，转交控制权给hello，然后hello终止，还原shell进程的context，转交控制权。

### 1.7.2 线程
现代系统里一个进程内部有多个执行单元，称为线程。

线程在进程的context中共享了code和global data

线程的好处：1.服务器并发 2.线程之间更容易分享数据，3.比进程更高效。

并发会在1.9.2讲，具体的线程程序在12章讲。


### 1.7.3 虚拟内存
虚拟内存是每个进程看似独占主存的假象的抽象。每个进程都有一个对内存的统一视图：虚拟地址空间（virtual address space），结构可以见下图：
![image](https://user-images.githubusercontent.com/47411365/149354828-1ef9976d-5d6c-4f21-b2f8-ebcb214c2840.png)

我们来捋一捋上面图片的几个部分：
- 程序的代码和数据。从所有进程相同固定地址开始，然后是存了c的全局的数据的位置
- 堆。不同于code和data，heap会在运行时扩大缩小（调用的malloc和free）
- 共享的lib（在第七章链接的时候接着讲）
- 栈。 函数调用栈调用会增长，return会收缩
- kernel virtual memory。最上层给kernel，用户程序不能直接调用。

### 1.7.4 files
file只是串字节，但是所有io设备都可以被建模成file，这样就能统一接口了。

## 1.8 Systems Communicate with Other Systems Using Networks
感觉。。不如计算机网络

![image](https://user-images.githubusercontent.com/47411365/149356309-8a6ea81d-2e13-4e8e-9dc9-ea1aa0bfd636.png)

## 1.9 重要的主题
### 1.9.1 安达尔定律
主要思想是，如果要加速一个系统的一部分，对整个系统而言效果取决于这个部分对这个系统多重要，以及这部分能提速多少。

假设系统的某些部分需要α的分数，我们将其性能提高了k倍。也就是说，组件最初需要的时间为αTold，现在需要时间(αTold)/k。

![image](https://user-images.githubusercontent.com/47411365/149357005-618a7ff8-21f7-45a0-91a4-5ee91f72ae0c.png)

作为一个例子，考虑一下系统中最初消耗60%时间的一部分（α=0.6）被加速了3倍(k=3)。然后我们得到了一个加速的1/[0.4+0.6/3]=1.67×

### 1.9.2 并发和并行
我们用术语并发表示同时有多个活动的系统

我们用属于并行表示的并发会让系统更快

#### 线程级并发
传统的并发只是但计算机有反复横跳切换的功能（1960s）

现在多核处理器发展出了多核和超线程技术（下方是不同的处理器类型）：

![image](https://user-images.githubusercontent.com/47411365/149358023-b675a04a-a085-48a2-a21b-fbb849d7e1db.png)

多核处理器的构成：

![无标题](https://user-images.githubusercontent.com/47411365/149358347-f81bb7fa-af7e-4481-b747-b3605afa82c1.png)

这些核心共享更高级的缓存和主存接口。

超线程，又称为同时的多线程，一个让单cpu执行多个控制流的技术。会单独的增加一些pc，寄存器，其他的还是一个（比如ALU），传统处理器切线程要2000时钟周期，超线程只要1个。

这让cpu更好的利用进程的资源，如果一个线程必须等待某些数据被加载倒cache中，那cpu可以创建另外一个线程。

多核处理技术可以这样优化系统性能：1.减少运行多任务的消耗 2.在程序员能好好地使用多线程的情况下，app能运行的更快






