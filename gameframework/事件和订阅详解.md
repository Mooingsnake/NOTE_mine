## 前言
【C#】 委托,事件 订阅.md  已经讲了关于gameframework的一部分知识，如果还不会C# 的基础知识委托，可以搜索【事件 订阅】在左上角。



这里只会举一个例子来告诉你如何查看gameframework的订阅内容。我用的是OnLoadDataTableSuccess这个函数，也就是成功加载数据表的时候调用：

![image](https://user-images.githubusercontent.com/47411365/142661549-39a2a0dc-adcd-440c-9c8a-9896094d1b94.png)

![image](https://user-images.githubusercontent.com/47411365/142661583-173de268-37f6-44d2-85c2-d47ff674dbf1.png)


## 问题引入
```
        GameEntry.Event.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);
```
```
        private void OnLoadDataTableSuccess(object sender, GameEventArgs e)
        {
            LoadDataTableSuccessEventArgs ne = (LoadDataTableSuccessEventArgs)e;
            if (ne.UserData != this)
            {
                return;
            }
        
            Log.Info("Load data table '{0}' OK.", ne.DataTableAssetName);
        }
```
(两段代码均来自ProcedurePreload.cs)

两个问题：1.第一个参数是官方提供的事件参数，它什么时候发生？ 2.第二个参数是一个函数，这个函数里面的这个参数GameEventArgs e我们如何控制？

因为我自己外部实现了一个LubanComponent来导入数据表，导致监听的时候OnLoadDataTableSuccess这个函数根本没有被调用，同样我也担心 ne.DataTableAssetName没有办法指定我想要的名字。

![image](https://user-images.githubusercontent.com/47411365/142662203-b38599cc-61c0-4b2b-af24-6cadd51321a5.png)

（上图和StarForce的区别就是没有成功加载.txt文件的log）


## XXXEventArgs

打开作者的UnityGameFramework这个仓库

注册和调用，其中Fire和Subsribe的区别是，Fire是runtime里面发射多次同名事件的最前线，Subsribe是订阅一次终身会员：

![image](https://user-images.githubusercontent.com/47411365/142664165-848d86bf-d414-4e02-a055-2a19acb0e1a1.png)

我们去下面那个看看：

```
        private void OnReadDataSuccess(object sender, ReadDataSuccessEventArgs e)
        {
            m_EventComponent.Fire(this, LoadDataTableSuccessEventArgs.Create(e));
        }
```
接近了，同文件内上面写了它的多播：

![image](https://user-images.githubusercontent.com/47411365/142664733-02feb5c9-adeb-40e1-8e3f-818655cac1d0.png)

意思是说不用这个函数就不会调用这些函数，也包括LoadDataTableSuccessEventArgs。也就是说我们必须要像这样使用DataTableComponent.CreateDataTable才可以:

![image](https://user-images.githubusercontent.com/47411365/142665088-96637590-9861-44b2-8c52-58a3963f29fd.png)

右上角显示来自StarForce里面自己静态拓展出来的DataExtension类，封装好以后再去调用，不要忘记随时检查异步加载完成情况：
from:ProcedurePreload.CS
```
        private void LoadDataTable(string dataTableName)
        {
            string dataTableAssetName = AssetUtility.GetDataTableAsset(dataTableName, false);
            m_LoadedFlag.Add(dataTableAssetName, false);
            GameEntry.DataTable.LoadDataTable(dataTableName, dataTableAssetName, this);
        }
```

## (object sender, GameEventArgs e)

来自:
```
        private void OnLoadDataTableSuccess(object sender, GameEventArgs e)
        {
            LoadDataTableSuccessEventArgs ne = (LoadDataTableSuccessEventArgs)e;
            if (ne.UserData != this)
            {
                return;
            }
        
            Log.Info("Load data table '{0}' OK.", ne.DataTableAssetName);
        }
```

刚刚我们看到哪里，接着往下看看：
from:DataTableBase  
```
        /// <summary>
        /// 读取数据表成功事件。
        /// </summary>
        public event EventHandler<ReadDataSuccessEventArgs> ReadDataSuccess
        {
            add
            {
                m_DataProvider.ReadDataSuccess += value;
            }
            remove
            {
                m_DataProvider.ReadDataSuccess -= value;
            }
        }
```
我不想更新了，总之就这样把，看不懂没关系，可能是语法还不够熟练，这边建议去看微软爸爸的教程：

https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/how-to-publish-events-that-conform-to-net-framework-guidelines

更简单的模型是这个：

https://docs.microsoft.com/zh-cn/dotnet/api/system.eventhandler-1?view=net-6.0

虽然懒的写，但是我录视频了：https://www.bilibili.com/video/BV1pr4y1k7zH/
